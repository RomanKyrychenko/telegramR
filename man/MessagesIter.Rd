% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/messages.R
\name{MessagesIter}
\alias{MessagesIter}
\title{MessagesIter}
\description{
Telegram API type MessagesIter
}
\details{
MessagesIter R6 class

Iterator over messages with support for search, filters, reply threads,
scheduled history, ranges (min_id/max_id), and reverse iteration.
This is a translation of the original async RequestIter-based logic into R6.
It delegates fetching to the provided client via iter_messages().
}
\section{Public fields}{
\if{html}{\out{<div class="r6-fields">}}
\describe{
\item{\code{client}}{Client used to perform requests}

\item{\code{entity_input}}{Input entity (resolved via client get_input_entity if available)}

\item{\code{is_global}}{Whether this is a global search (entity is NULL)}

\item{\code{reverse}}{Whether to iterate in reverse}

\item{\code{limit}}{Hard limit of messages to retrieve}

\item{\code{left}}{Remaining messages to retrieve}

\item{\code{wait_time}}{Optional per-request wait time (seconds)}

\item{\code{add_offset}}{Add offset used by server requests}

\item{\code{max_id}}{Upper bound for message id (exclusive)}

\item{\code{min_id}}{Lower bound for message id (exclusive)}

\item{\code{last_id}}{Last seen message id (used to avoid duplicates/order issues)}

\item{\code{total}}{Total messages reported by the server (when available)}

\item{\code{request}}{Request parameters tracked between chunks}

\item{\code{buffer}}{Internal buffer of fetched messages}

\item{\code{exhausted}}{Exhausted flag}

\item{\code{from_id}}{From-user peer id for local filtering when needed}

\item{\code{search}}{Optional search query}

\item{\code{filter}}{Optional filter object}

\item{\code{reply_to}}{Optional reply thread id}

\item{\code{offset_date}}{Optional offset date}
}
\if{html}{\out{</div>}}
}
\section{Methods}{
\subsection{Public methods}{
\itemize{
\item \href{#method-MessagesIter-new}{\code{MessagesIter$new()}}
\item \href{#method-MessagesIter-load_next_chunk}{\code{MessagesIter$load_next_chunk()}}
\item \href{#method-MessagesIter-has_next}{\code{MessagesIter$has_next()}}
\item \href{#method-MessagesIter-.next}{\code{MessagesIter$.next()}}
\item \href{#method-MessagesIter-clone}{\code{MessagesIter$clone()}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-MessagesIter-new"></a>}}
\if{latex}{\out{\hypertarget{method-MessagesIter-new}{}}}
\subsection{Method \code{new()}}{
Initialize the iterator with query parameters.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{MessagesIter$new(
  client,
  entity = NULL,
  offset_id = 0L,
  min_id = 0L,
  max_id = 0L,
  from_user = NULL,
  offset_date = NULL,
  add_offset = 0L,
  filter = NULL,
  search = NULL,
  reply_to = NULL,
  scheduled = FALSE,
  reverse = FALSE,
  wait_time = NULL,
  limit = Inf
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{client}}{Telegram client object that provides iter_messages(), collect(), collect_one().}

\item{\code{entity}}{Optional entity to iterate (NULL for global search).}

\item{\code{offset_id}}{Integer offset id start.}

\item{\code{min_id}}{Integer minimum id (exclusive).}

\item{\code{max_id}}{Integer maximum id (exclusive).}

\item{\code{from_user}}{Optional user entity to filter from.}

\item{\code{offset_date}}{POSIXct or Date to offset by date.}

\item{\code{add_offset}}{Integer additional offset.}

\item{\code{filter}}{Optional filter object or constructor.}

\item{\code{search}}{Optional text query.}

\item{\code{reply_to}}{Optional message id to iterate replies to.}

\item{\code{scheduled}}{Logical; if TRUE, scheduled messages history is used.}

\item{\code{reverse}}{Logical; if TRUE, oldest to newest.}

\item{\code{wait_time}}{Optional per-request sleep in seconds.}

\item{\code{limit}}{Integer or Inf, maximum messages to yield.
Load next chunk

Fetches the next chunk of messages and appends them to the internal buffer.}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-MessagesIter-load_next_chunk"></a>}}
\if{latex}{\out{\hypertarget{method-MessagesIter-load_next_chunk}{}}}
\subsection{Method \code{load_next_chunk()}}{
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{MessagesIter$load_next_chunk()}\if{html}{\out{</div>}}
}

\subsection{Returns}{
A list of messages for this chunk or NULL if exhausted.
Check if there are more items to retrieve
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-MessagesIter-has_next"></a>}}
\if{latex}{\out{\hypertarget{method-MessagesIter-has_next}{}}}
\subsection{Method \code{has_next()}}{
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{MessagesIter$has_next()}\if{html}{\out{</div>}}
}

\subsection{Returns}{
logical indicating whether there are more items to fetch or buffered.
Get the next item, fetching more if needed
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-MessagesIter-.next"></a>}}
\if{latex}{\out{\hypertarget{method-MessagesIter-.next}{}}}
\subsection{Method \code{.next()}}{
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{MessagesIter$.next()}\if{html}{\out{</div>}}
}

\subsection{Returns}{
A single message object or NULL if exhausted.
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-MessagesIter-clone"></a>}}
\if{latex}{\out{\hypertarget{method-MessagesIter-clone}{}}}
\subsection{Method \code{clone()}}{
The objects of this class are cloneable with this method.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{MessagesIter$clone(deep = FALSE)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{deep}}{Whether to make a deep clone.}
}
\if{html}{\out{</div>}}
}
}
}
