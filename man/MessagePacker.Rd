% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/messagepacker.R
\name{MessagePacker}
\alias{MessagePacker}
\title{MessagePacker}
\description{
MessagePacker collects state items (requests and associated metadata),
assigns message ids, and packs one or more TL messages into a single byte
payload. When multiple messages are present they are wrapped in a
MessageContainer. The class exposes a simple FIFO deque interface and a
blocking `get` method that returns the next batch of messages and the
corresponding serialized bytes ready to be sent.

Telegram API type MessagePacker
}
\details{
MessagePacker R6 class

This method also sets `ready` to \code{TRUE} to notify any
  waiting `get` calls that new data is available.

Each element in `states` is appended in order. `ready` is set to
  \code{TRUE} after extension.


- If an individual message exceeds the maximum allowed size it will be
  skipped and, if present, `state_item$future$set_exception` will be
  called with a simple error. A warning is logged when a payload is too large.
- Logging calls are guarded so that failures in logger methods do not
  interrupt packing.
}
\section{Public fields}{
\if{html}{\out{<div class="r6-fields">}}
\describe{
\item{\code{state}}{External state/transport object used to actually write message
bytes and generate message ids via `write_data_as_message`.}

\item{\code{deque}}{Internal list used as a FIFO queue of state items.}

\item{\code{ready}}{Logical flag that signals that new items were added to the queue.}

\item{\code{log}}{Optional logger object with methods like `debug` and `warning`.}
}
\if{html}{\out{</div>}}
}
\section{Methods}{
\subsection{Public methods}{
\itemize{
\item \href{#method-MessagePacker-new}{\code{MessagePacker$new()}}
\item \href{#method-MessagePacker-append}{\code{MessagePacker$append()}}
\item \href{#method-MessagePacker-extend}{\code{MessagePacker$extend()}}
\item \href{#method-MessagePacker-get}{\code{MessagePacker$get()}}
\item \href{#method-MessagePacker-clone}{\code{MessagePacker$clone()}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-MessagePacker-new"></a>}}
\if{latex}{\out{\hypertarget{method-MessagePacker-new}{}}}
\subsection{Method \code{new()}}{
Initialize a MessagePacker
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{MessagePacker$new(state, loggers = list())}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{state}}{An object implementing `write_data_as_message(buffer_con, data, ...)`
used to serialize individual messages and return their `msg_id`.}

\item{\code{loggers}}{Optional list of logger instances. If a `"messagepacker"`
entry exists it will be used; otherwise the first logger in the list
will be used as a fallback.}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-MessagePacker-append"></a>}}
\if{latex}{\out{\hypertarget{method-MessagePacker-append}{}}}
\subsection{Method \code{append()}}{
Append a single state item to the queue
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{MessagePacker$append(state_item)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{state_item}}{A list-like object representing a request payload and
associated metadata. Items are appended to the right (tail) of the deque.}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-MessagePacker-extend"></a>}}
\if{latex}{\out{\hypertarget{method-MessagePacker-extend}{}}}
\subsection{Method \code{extend()}}{
Extend the queue with multiple state items
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{MessagePacker$extend(states)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{states}}{An iterable (e.g. list) of state items to append to the queue.}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-MessagePacker-get"></a>}}
\if{latex}{\out{\hypertarget{method-MessagePacker-get}{}}}
\subsection{Method \code{get()}}{
This method blocks (simple polling) until at least one item is available.
It then accumulates items from the deque into a batch while respecting
`MessageContainer$MAXIMUM_LENGTH` and `MessageContainer$MAXIMUM_SIZE`.
For each included state item it calls `self$state$write_data_as_message`
to serialize the message into a temporary raw connection and obtain a
`msg_id`. If multiple messages are batched they are wrapped into a
container and a single container message is produced; otherwise the single
message bytes are returned.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{MessagePacker$get()}\if{html}{\out{</div>}}
}

\subsection{Returns}{
A list of two elements:
  - `batch`: a list of state items that were included (or NULL if none),
  - `bytes`: raw vector with serialized bytes ready to send (or NULL if none).
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-MessagePacker-clone"></a>}}
\if{latex}{\out{\hypertarget{method-MessagePacker-clone}{}}}
\subsection{Method \code{clone()}}{
The objects of this class are cloneable with this method.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{MessagePacker$clone(deep = FALSE)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{deep}}{Whether to make a deep clone.}
}
\if{html}{\out{</div>}}
}
}
}
